---
layout: post
title:  "Wut Wut"
date:   2014-09-10 20:45:35
author: Porter Smith
categories: linux
---

At a recent GLUG meeting the topic of *shebang* lines came up.
This lead to a long off-topic discussion which lead to me doing a little bit of research into what these are and how they work.

Scripts (such as bash or python) are interpreted, meaning that some program (the interpreter) must read and executes the lines of code. 
Because of this, scripts can't be executed directly by the system. You've probably before run a python as `python script.py`.
Often, for convenience, we'd like to be able to run our scripts as though they were normal binaries, by setting the file's executable bit and executing it directly.
This sometimes done for transparency, as it's often convenient to have a script wrapper around running a binary (for example, to set some environment variables).

A shebang (or hashbang) is a line at the start of a script file that tells the OS *how* to execute the script.
You've probably seen something like this at the top of a bash script:

```sh
#!/bin/bash
echo "You can call this script directly from the command line!"
```

If set the file as executable (`chmod +x script.sh`), then you can run it directly (`./script.sh`)!

Initially I sort of assumed this was handled by the shell (bash in this case), until another member mentioned that a raw exec system call was able to execute scripts with a shebang as well.
I was curious where exactly this all was taking place, so I did some digging in the kernel code.
All of the links and code snippets in this post refer to version 4.4 of the linux kernel, though it seems like this area of the kernel is pretty consistent.

Since the exec syscalls do handle these shebang script, I decided to start there.
First we start at [the definition of `do_execveat_common()`](https://github.com/torvalds/linux/blob/v4.4/fs/exec.c#L1484), which is the basis for the whole exec family of syscalls.
In there, we see a call to `exec_binprm()` (that is, *bin*ary *pr*ogra*m*), which in turn calls `search_binary_handler()`.

[`search_binary_handler()`](https://github.com/torvalds/linux/blob/v4.4/fs/exec.c#L1406) is responsible for finding a suitable binary handler for the given binary. 
The handler is responsible for taking the raw binary and initializing it in memory, which involves setting up the memory space for the new process and making sure everything is initialized.
This seems promising, but nothing so far seems to handle scripts in particular!
Well, this small loop does seem to be doing some interesting stuff:

```C
list_for_each_entry(fmt, &formats, lh) {
    if (!try_module_get(fmt->module))
        continue;
    ...
    retval = fmt->load_binary(bprm);
    ...
    if (retval != -ENOEXEC || !bprm->file) {
        read_unlock(&binfmt_lock);
        return retval;
    }
}
```

Interesting! The kernel, loops over some number of binary handlers and tries to load our binary with each one.
Once we find one that that doesn't return `-ENOEXEC`, then we know we have successfully loaded our binary!
Now what kinds of handlers are available? In the `linux/fs` we can find `binfmt_aout.c`, `binfmt_elf.c`, `binfmt_flat.c`, and finally, what we've been waiting for, [`binfmt_script.sh`](https://github.com/torvalds/linux/blob/v4.4/fs/binfmt_script.c)!
